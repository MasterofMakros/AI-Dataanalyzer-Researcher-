#!/usr/bin/env python3
from __future__ import annotations

import argparse
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List


@dataclass
class PrpEntry:
    feature_id: str
    name: str
    status: str
    prp_path: str
    dependencies: List[str]
    validations: List[str]


PRP_HEADER_RE = re.compile(r"^# PRP:\s+(?P<name>.+?)\s+\((?P<id>[^)]+)\)\s*$")
FEATURE_ID_RE = re.compile(r"^[A-Z]+-\d{3}$")
STATE_RE = re.compile(r"^- State:\s+(?P<state>.+)$", re.IGNORECASE)


def parse_prp(path: Path) -> PrpEntry | None:
    lines = path.read_text(encoding="utf-8").splitlines()
    name = ""
    feature_id = ""
    status = "planned"
    dependencies: List[str] = []
    validations: List[str] = []

    in_components = False
    in_test_plan = False

    for line in lines:
        header_match = PRP_HEADER_RE.match(line)
        if header_match:
            name = header_match.group("name").strip()
            feature_id = header_match.group("id").strip()
            continue

        state_match = STATE_RE.match(line.strip())
        if state_match:
            status = state_match.group("state").strip()
            continue

        if line.strip().startswith("## Architecture Impact"):
            in_components = False
            continue

        if line.strip().startswith("- Components touched:"):
            in_components = True
            in_test_plan = False
            continue

        if line.strip().startswith("## Test Plan"):
            in_test_plan = True
            in_components = False
            continue

        if line.strip().startswith("## "):
            in_components = False
            in_test_plan = False
            continue

        if in_components and line.startswith("  - "):
            dependency = line.strip()[2:].strip()
            if dependency:
                dependencies.append(dependency)
            continue

        if in_test_plan and line.strip().startswith("- [ ]"):
            command = line.split("- [ ]", 1)[-1].strip()
            if command:
                validations.append(command)

    if not feature_id or not name:
        return None
    if not FEATURE_ID_RE.match(feature_id):
        return None

    return PrpEntry(
        feature_id=feature_id,
        name=name,
        status=status,
        prp_path=path.as_posix(),
        dependencies=dependencies,
        validations=validations,
    )


def iter_prps(prp_dir: Path) -> Iterable[Path]:
    for path in sorted(prp_dir.glob("*.md")):
        if path.name == "README.md":
            continue
        yield path


def build_backlog(prp_dir: Path) -> List[PrpEntry]:
    entries: List[PrpEntry] = []
    for path in iter_prps(prp_dir):
        entry = parse_prp(path)
        if entry is None:
            continue
        entries.append(entry)
    return sorted(entries, key=lambda entry: entry.feature_id)


def render_table(entries: List[PrpEntry]) -> str:
    header = (
        "# Feature Backlog\n\n"
        "> Generated by `scripts/generate_feature_backlog.py` from PRPs.\n\n"
        "| ID | Feature | Status | PRP | AbhÃ¤ngigkeiten | Validierung |\n"
        "| --- | --- | --- | --- | --- | --- |\n"
    )
    rows = []
    for entry in entries:
        dependencies = ", ".join(entry.dependencies) if entry.dependencies else "-"
        validations = ", ".join(entry.validations) if entry.validations else "-"
        rows.append(
            f"| {entry.feature_id} | {entry.name} | {entry.status} |"
            f" {entry.prp_path} | {dependencies} | {validations} |\n"
        )
    return header + "".join(rows)


def main() -> int:
    parser = argparse.ArgumentParser(description="Generate FEATURE_BACKLOG.md from PRPs.")
    parser.add_argument("--prp-dir", type=Path, default=Path("PRPs"))
    parser.add_argument("--output", type=Path, default=Path("docs/FEATURE_BACKLOG.md"))
    args = parser.parse_args()

    entries = build_backlog(args.prp_dir)
    args.output.parent.mkdir(parents=True, exist_ok=True)
    args.output.write_text(render_table(entries), encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
